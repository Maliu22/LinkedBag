package day0912ex2outline;/** * A class of bags whose entries are stored in a chain of single-linked nodes. * The bag is never full. */public class LinkedBag<T> implements BagI<T> {	private Node<T> head; // reference to first node	private int size; // number of entries	public LinkedBag() {		head = null;		size = 0;	}	/**	 * Sees whether this bag is empty.	 * 	 * @return true if the bag is empty, or false if not	 */	@Override	public boolean isEmpty() {		return size == 0;	}	/**	 * Gets the number of entries currently in this bag.	 * 	 * @return the integer number of entries currently in the bag	 */	@Override	public int getCurrentSize() {		return size;	}	/**	 * Adds a new entry to this bag.	 * 	 * @param newEntry	 *            the object to be added as a new entry	 * @return true if the addition is successful, or false if not	 */	@Override	public boolean add(T newEntry) {		if (isFull())			return false;		Node<T> toAdd = new Node<T>(newEntry);		toAdd.next = head;		head = toAdd;		size++;		return true;	}	/**	 * Sees whether this bag is full.	 * 	 * @return false	 */	@Override	public boolean isFull() {		return false;	}	/**	 * Removes one unspecified entry from this bag, if possible.	 * 	 * @return either the removed entry, if the removal was successful, or null	 */	@Override	public T remove() {		if (isEmpty())			return null;		Node<T> toRemove = head;		head = head.next;		size--;		return toRemove.data;	}	/**	 * Removes one occurrence of a given entry from this bag.	 * 	 * @param anEntry	 *            the entry to be removed	 * @return true if the removal was successful, or false otherwise	 */	@Override	public boolean remove(T anEntry) {		if (isEmpty())			return false;		Node<T> temp = head;	//checks if the node to remove is the first one		if (temp.data.equals(anEntry)) {			head = head.next;			size--;			return true;		}		for (int i = 0; i < size - 2; i++) {			if (temp.next.data.equals(anEntry)) {				temp.next = temp.next.next;				this.size--;				return true;			} else {				temp = temp.next;			}		}		return false;	}		/* Locate a given entry within this bag. 	 * Returns a reference to the node containing the entry. If located, or null otherwise	 * 	 * private Node getReferenceTo(T anEntry){	 * boolean found = false;	 * 	 * Node currentNode = firstNode;	 * 	 * while(!found && (currentNode !=null){	 * if(anEntry.equals(currentNode.data){	 * found=true;	 * }else{	 * currentNode = currentNode.next;	 * }	 * 	 * }	 * return currentNode;	 * }	 * 	 *----------------------------------------	 *	 *public boolean remove(T anEntry){	 *boolean result = false;	 *	 *Node nodeN = getReferenceTo(T anEntry);	 *	 *if(nodeN !=null){	 *replace located entry with entry in first node, remove first node	 *nodeN.data = firstNode.data;	 *	 *remove();	 *result = true;	 *}	 *return result;	 *}	 * 	 */	/** Removes all entries from this bag. */	@Override	public void clear() {		this.head = null;		size = 0;	}	/**	 * Counts the number of times a given entry appears in this bag.	 * 	 * @param anEntry	 *            the entry to be counted	 * @return the number of times anEntry appears in the bag	 */	@Override	public int getFrequencyOf(T anEntry) {		int count = 0;		Node<T> temp = head;		for (int i = 0; i < size; i++) {			if (temp.data.equals(anEntry)) {				count++;			}			temp = temp.getNext();		}		return count;	}	/**	 * Tests whether this bag contains a given entry.	 * 	 * @param anEntry	 *            the entry to locate	 * @return true if the bag contains anEntry, or false otherwise	 */	@Override	public boolean contains(T anEntry) {		if (isEmpty())			return false;		Node<T> temp = head;		for (int i = 0; i < size; i++) {			if (temp.data.equals(anEntry)) {				return true;			} else {				temp = temp.getNext();			}		}		return false;	}	/**	 * Retrieves all entries that are in this bag.	 * 	 * @return a newly allocated array of all the entries in the bag	 */	@Override	public T[] toArray() {		// the cast is safe because the new array contains null entries		@SuppressWarnings("unchecked")		T[] result = (T[]) new Object[size]; // unchecked cast		int index = 0;		Node<T> currentNode = head;		while (currentNode != null) {			result[index] = currentNode.data;			index++;			currentNode = currentNode.next;		}		return result;	}	// if not static - the inner class can use the instance fields from the	// outer class and the T	//if it is not static we don`t need to write <T>	//A inner class is a nested class that is not static	private static class Node<T> {		// all fields are visible to the outer class		private T data; // entry in bag		private Node<T> next; // link to next node		public Node(T data) {			this(data, null);		}		public Node(T data, Node<T> next) {			this.data = data;			this.next = next;		}		/*		 * public T getData() { return data; }		 */		public Node<T> getNext() {			return next;		}	} // end Node<T> class} // end LinkedBag<T> class